{"prompt": "Explícame qué es una variable en Python.", "response": "Una variable en Python es un contenedor para almacenar datos. Se crea al asignar un valor con el operador =. Ejemplo: edad = 25. Python es de tipado dinámico, así que no necesitas declarar el tipo."}
{"prompt": "¿Cómo funciona el if-else en Python?", "response": "El if-else permite ejecutar código condicionalmente. Sintaxis: if condición: código else: código. Ejemplo:\nx = 10\nif x > 0:\n    print('Positivo')\nelse:\n    print('Negativo o cero')"}
{"prompt": "Muéstrame cómo definir una función en Python.", "response": "Para definir una función usas def. Ejemplo:\ndef saludar(nombre):\n    return f'Hola {nombre}'\n\nprint(saludar('Ana'))\n# Las funciones pueden tener parámetros y valores de retorno."}
{"prompt": "¿Qué son las listas en Python?", "response": "Las listas son colecciones ordenadas y mutables. Se crean con corchetes: mi_lista = [1, 2, 3]. Puedes acceder por índice: mi_lista[0] da 1. Métodos comunes: append(), remove(), sort()."}
{"prompt": "Explica el bucle for en Python.", "response": "El for itera sobre una secuencia. Sintaxis: for elemento in secuencia: código. Ejemplo:\nfor i in range(5):\n    print(i)  # Imprime 0 al 4\nTambién funciona con listas, strings, etc."}
{"prompt": "¿Cómo manejar excepciones en Python?", "response": "Usa try-except para manejar errores:\ntry:\n    resultado = 10 / 0\nexcept ZeroDivisionError:\n    print('No se puede dividir por cero')\nfinally:\n    print('Esto siempre se ejecuta')"}
{"prompt": "Diferencia entre tuple y list en Python.", "response": "Las listas son mutables (se pueden modificar) y usan []. Las tuplas son inmutables y usan (). Ejemplos:\nlista = [1, 2, 3]  # mutable\ntupla = (1, 2, 3)  # inmutable\nLas tuplas son más rápidas y seguras para datos fijos."}
{"prompt": "¿Qué es un diccionario en Python?", "response": "Un diccionario almacena pares clave-valor. Se crea con llaves: {'nombre': 'Juan', 'edad': 30}. Acceso: diccionario['nombre'] da 'Juan'. Métodos útiles: keys(), values(), items()."}
{"prompt": "Cómo leer un archivo en Python.", "response": "Usa open() con modo 'r' (lectura):\nwith open('archivo.txt', 'r') as archivo:\n    contenido = archivo.read()\n# El with cierra automáticamente el archivo\nPara leer línea por línea: for linea in archivo:"}
{"prompt": "Explica qué son los módulos en Python.", "response": "Los módulos son archivos .py que contienen código reusable. Se importan con import. Ejemplo:\nimport math\nprint(math.sqrt(16))  # 4.0\nTambién puedes importar partes específicas: from math import pi"}
{"prompt": "¿Cómo ordenar una lista en Python?", "response": "Usa el método sort() para ordenar in-place o sorted() para nueva lista:\nlista = [3, 1, 2]\nlista.sort()  # lista ahora es [1, 2, 3]\nordenada = sorted(lista, reverse=True)  # descendente"}
{"prompt": "Qué hace el método split() en strings.", "response": "split() divide un string en una lista usando un separador. Por defecto separa por espacios:\nfrase = 'Hola mundo Python'\npalabras = frase.split()  # ['Hola', 'mundo', 'Python']\nCon separador: 'a,b,c'.split(',') da ['a', 'b', 'c']"}
{"prompt": "Cómo funciona range() en Python.", "response": "range() genera una secuencia de números. Sintaxis: range(inicio, fin, paso). Ejemplos:\nrange(5)  # 0,1,2,3,4\nrange(1, 6)  # 1,2,3,4,5\nrange(0, 10, 2)  # 0,2,4,6,8\nÚtil para bucles for."}
{"prompt": "Explica comprensión de listas en Python.", "response": "Es una forma concisa de crear listas. Sintaxis: [expresión for elemento in secuencia]. Ejemplos:\ncuadrados = [x**2 for x in range(5)]  # [0,1,4,9,16]\npares = [x for x in range(10) if x % 2 == 0]  # [0,2,4,6,8]"}
{"prompt": "Diferencia entre == e is en Python.", "response": "== compara valores, is compara identidad (si son el mismo objeto). Ejemplo:\na = [1,2,3]\nb = [1,2,3]\na == b  # True (mismos valores)\na is b  # False (objetos diferentes)\nPara None siempre usa is: if valor is None:"}
{"prompt": "Cómo trabajar con fechas en Python.", "response": "Usa el módulo datetime:\nfrom datetime import datetime\nhoy = datetime.now()\nfecha_str = hoy.strftime('%d/%m/%Y')\nprint(f'Hoy es {fecha_str}')\nTambién puedes crear fechas específicas: datetime(2024, 12, 25)"}
{"prompt": "Qué son los decoradores en Python.", "response": "Los decoradores modifican funciones. Ejemplo básico:\ndef mi_decorador(func):\n    def wrapper():\n        print('Antes de la función')\n        func()\n        print('Después de la función')\n    return wrapper\n\n@mi_decorador\ndef saludar(): print('Hola')"}
{"prompt": "Cómo instalar un paquete con pip.", "response": "Usa pip desde la terminal:\npip install nombre_paquete\nPara una versión específica:\npip install numpy==1.21.0\nPara instalar desde requirements.txt:\npip install -r requirements.txt"}
{"prompt": "Explica el operador ** en Python.", "response": "** es el operador de exponenciación. Ejemplo:\n2 ** 3  # 8 (2 elevado a 3)\nTambién se usa para desempaquetar diccionarios:\ndef funcion(a, b): return a + b\ndic = {'a': 1, 'b': 2}\nfuncion(**dic)  # 3"}
{"prompt": "Cómo usar enumerate() en un bucle.", "response": "enumerate() devuelve índice y valor:\nfrutas = ['manzana', 'banana', 'naranja']\nfor indice, fruta in enumerate(frutas):\n    print(f'{indice}: {fruta}')\n# Salida:\n# 0: manzana\n# 1: banana\n# 2: naranja"}
{"prompt": "Qué hace el método join() en strings.", "response": "join() une elementos de una lista en un string:\npalabras = ['Python', 'es', 'genial']\nfrase = ' '.join(palabras)  # 'Python es genial'\nrutas = '-'.join(['a', 'b', 'c'])  # 'a-b-c'\nEs más eficiente que concatenar con + en bucles."}
{"prompt": "Cómo usar zip() para iterar múltiples listas.", "response": "zip() combina múltiples iterables:\nnombres = ['Ana', 'Juan', 'Luis']\nedades = [25, 30, 35]\nfor nombre, edad in zip(nombres, edades):\n    print(f'{nombre} tiene {edad} años')\n# Se detiene cuando la lista más corta termina"}
{"prompt": "Explica lambda functions en Python.", "response": "Las lambdas son funciones anónimas de una línea. Sintaxis: lambda argumentos: expresión. Ejemplo:\nduplicar = lambda x: x * 2\nprint(duplicar(5))  # 10\nÚtiles con map(), filter(), sorted(): sorted(lista, key=lambda x: x[1])"}
{"prompt": "Cómo copiar una lista correctamente.", "response": "Para copiar superficial: lista_copia = lista_original.copy() o lista_copia = lista_original[:]. Para copia profunda (con listas anidadas):\nimport copy\nlista_copia = copy.deepcopy(lista_original)\n# Así modificaciones en copia no afectan original"}
{"prompt": "Qué son los sets en Python.", "response": "Los sets son colecciones no ordenadas de elementos únicos. Se crean con {} o set(). Ejemplo:\nmi_set = {1, 2, 3, 3, 2}  # {1, 2, 3}\nOperaciones útiles: union(), intersection(), difference().\nÚtiles para eliminar duplicados: lista_sin_dups = list(set(lista_con_dups))"}
{"prompt": "Cómo convertir tipos de datos en Python.", "response": "Usa las funciones de conversión:\nstr(123)  # '123'\nint('456')  # 456\nfloat('3.14')  # 3.14\nlist('abc')  # ['a', 'b', 'c']\ntuple([1,2,3])  # (1,2,3)\nSiempre verifica que la conversión sea válida."}
{"prompt": "Explica f-strings en Python 3.6+.", "response": "Los f-strings permiten formateo fácil de strings. Ejemplo:\nnombre = 'Carlos'\nedad = 30\nprint(f'{nombre} tiene {edad} años')\n# También expresiones:\nprint(f'Dentro de 5 años tendrá {edad + 5} años')\n# Formateo de números:\nprint(f'Pi: {3.14159:.2f}')  # 'Pi: 3.14'"}
{"prompt": "Cómo usar map() y filter().", "response": "map() aplica una función a cada elemento:\nnumeros = [1, 2, 3]\ncuadrados = list(map(lambda x: x**2, numeros))  # [1,4,9]\n\nfilter() filtra elementos:\npares = list(filter(lambda x: x % 2 == 0, numeros))  # [2]\nCon comprensión de listas a menudo es más legible."}
{"prompt": "Qué es __name__ == '__main__' en Python.", "response": "Esta condición verifica si el script se ejecuta directamente (no importado). Útil para tener código ejecutable y código importable:\ndef funcion():\n    return 'Hola'\n\nif __name__ == '__main__':\n    print(funcion())  # Solo se ejecuta al correr este archivo"}
{"prompt": "Cómo crear un generador en Python.", "response": "Los generadores usan yield en lugar de return. Ejemplo:\ndef contador_hasta(n):\n    i = 0\n    while i < n:\n        yield i\n        i += 1\n\nfor num in contador_hasta(5):\n    print(num)  # 0,1,2,3,4\nSon eficientes en memoria."}
{"prompt": "Explica herencia de clases en Python.", "response": "La herencia permite crear clases hijas que extienden padres. Ejemplo:\nclass Animal:\n    def __init__(self, nombre):\n        self.nombre = nombre\n\nclass Perro(Animal):\n    def ladrar(self):\n        print('¡Guau!')\n\nmi_perro = Perro('Fido')\nprint(mi_perro.nombre)  # 'Fido'\nmi_perro.ladrar()  # '¡Guau!'"}
{"prompt": "Cómo manejar archivos JSON en Python.", "response": "Usa el módulo json:\nimport json\n\n# Escribir JSON\ndatos = {'nombre': 'Ana', 'edad': 25}\nwith open('datos.json', 'w') as archivo:\n    json.dump(datos, archivo)\n\n# Leer JSON\nwith open('datos.json', 'r') as archivo:\n    datos_leidos = json.load(archivo)"}
{"prompt": "Qué son los métodos mágicos __str__ y __repr__.", "response": "__str__ devuelve string legible para usuario, __repr__ string preciso para desarrollador. Ejemplo:\nclass Punto:\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n    def __str__(self):\n        return f'Punto({self.x}, {self.y})'\n    def __repr__(self):\n        return f'Punto({self.x}, {self.y})'\n\np = Punto(1, 2)\nprint(p)  # Usa __str__"}
{"prompt": "Cómo usar *args y **kwargs en funciones.", "response": "*args recibe múltiples argumentos posicionales como tupla, **kwargs recibe múltiples argumentos nombrados como diccionario. Ejemplo:\ndef funcion(*args, **kwargs):\n    print(f'args: {args}')\n    print(f'kwargs: {kwargs}')\n\nfuncion(1, 2, 3, nombre='Ana', edad=25)\n# args: (1, 2, 3)\n# kwargs: {'nombre': 'Ana', 'edad': 25}"}
{"prompt": "Explica el manejo de contextos con with.", "response": "El statement with garantiza que recursos se liberen correctamente. Se usa con objetos que tienen métodos __enter__ y __exit__. Ejemplo con archivos:\nwith open('archivo.txt', 'r') as archivo:\n    contenido = archivo.read()\n# Aquí el archivo ya está cerrado automáticamente\nTambién útil para locks, conexiones a BD, etc."}
{"prompt": "Cómo crear y usar un entorno virtual.", "response": "Crea un entorno virtual con:\npython -m venv nombre_entorno\n\nActivar en Windows:\nnombre_entorno\\Scripts\\activate\n\nActivar en Linux/Mac:\nsource nombre_entorno/bin/activate\n\nDesactivar en cualquier sistema:\ndeactivate\n\nAsí aislas dependencias de cada proyecto."}
{"prompt": "Qué es la mutabilidad en Python.", "response": "Los objetos mutables pueden cambiar después de creados (listas, diccionarios, sets). Los inmutables no (strings, tuplas, números). Ejemplo:\nlista = [1,2,3]\nlista[0] = 9  # OK, mutable\n\ncadena = 'hola'\n# cadena[0] = 'H'  # Error, inmutable\ncadena_nueva = 'H' + cadena[1:]  # Nueva cadena"}
{"prompt": "Cómo usar el módulo os para operaciones de sistema.", "response": "El módulo os permite interactuar con el SO:\nimport os\n\n# Directorio actual\nprint(os.getcwd())\n\n# Listar archivos\nprint(os.listdir('.'))\n\n# Verificar si existe\nprint(os.path.exists('archivo.txt'))\n\n# Unir rutas\nruta = os.path.join('carpeta', 'subcarpeta', 'archivo.txt')"}
{"prompt": "Explica la diferencia entre métodos de clase y estáticos.", "response": "Métodos de clase reciben cls como primer parámetro y pueden modificar estado de clase. Métodos estáticos no reciben self ni cls, son como funciones normales. Ejemplo:\nclass MiClase:\n    @classmethod\n    def metodo_clase(cls):\n        print(f'Método de {cls.__name__}')\n    \n    @staticmethod\n    def metodo_estatico():\n        print('Método estático')"}
{"prompt": "Cómo usar collections.defaultdict.", "response": "defaultdict crea diccionarios con valor por defecto automático:\nfrom collections import defaultdict\n\n# Diccionario de listas\nd = defaultdict(list)\nd['frutas'].append('manzana')  # No necesita inicializar lista\n\n# Con contadores\nd = defaultdict(int)\nd['visitas'] += 1  # Empieza en 0 automáticamente\n\n# Más limpio que verificar si clave existe"}
{"prompt": "Qué es la serialización con pickle.", "response": "Pickle serializa objetos Python a bytes:\nimport pickle\n\n# Guardar objeto\nwith open('datos.pkl', 'wb') as archivo:\n    pickle.dump([1, 2, 3], archivo)\n\n# Cargar objeto\nwith open('datos.pkl', 'rb') as archivo:\n    datos = pickle.load(archivo)\n\n# ¡Cuidado! Solo usar con datos seguros."}
{"prompt": "Cómo medir tiempo de ejecución en Python.", "response": "Usa time o timeit:\nimport time\n\ninicio = time.time()\n# Código a medir\ntime.sleep(1)\nfin = time.time()\nprint(f'Tiempo: {fin - inicio:.2f} segundos')\n\n# Para mediciones precisas:\nimport timeit\ntiempo = timeit.timeit('"-".join(str(n) for n in range(100))', number=10000)"}
{"prompt": "Explica el principio DRY en programación.", "response": "DRY significa 'Don't Repeat Yourself' (No te repitas). En lugar de copiar código, crea funciones reusables. Ejemplo:\n# MAL: Código repetido\nprint('El área es:', 5 * 3)\nprint('El área es:', 7 * 4)\n\n# BIEN: Función reutilizable\ndef calcular_area(ancho, alto):\n    return ancho * alto\n\nprint('El área es:', calcular_area(5, 3))\nprint('El área es:', calcular_area(7, 4))"}
{"prompt": "Cómo depurar código en Python.", "response": "Usa print() básico, pdb interactivo o breakpoints en IDE.\n\nCon pdb:\nimport pdb; pdb.set_trace()  # Punto de interrupción\n\nComandos pdb útiles:\nn: siguiente línea\nc: continuar\nq: salir\np variable: imprimir variable\nl: listar código\n\nO usa el debugger de tu IDE (VSCode, PyCharm)."}
{"prompt": "Qué hace el operador walrus := en Python 3.8+.", "response": "El operador walrus (:=) asigna valores dentro de expresiones. Ejemplo:\n# Sin walrus:\nlinea = input()\nwhile linea != 'salir':\n    print(linea)\n    linea = input()\n\n# Con walrus:\nwhile (linea := input()) != 'salir':\n    print(linea)\n\n# Útil en if y while para evitar código repetido."}
{"prompt": "Cómo crear paquetes en Python.", "response": "Un paquete es una carpeta con archivo __init__.py. Estructura:\nmi_paquete/\n    __init__.py\n    modulo1.py\n    modulo2.py\n    subpaquete/\n        __init__.py\n        modulo3.py\n\nsetup.py para distribuir:\nfrom setuptools import setup, find_packages\nsetup(name='mi_paquete', packages=find_packages())"}
{"prompt": "Explica el patrón Singleton en Python.", "response": "Singleton garantiza una sola instancia de clase. Implementación:\nclass Singleton:\n    _instancia = None\n    \n    def __new__(cls):\n        if cls._instancia is None:\n            cls._instancia = super().__new__(cls)\n        return cls._instancia\n\ns1 = Singleton()\ns2 = Singleton()\nprint(s1 is s2)  # True, misma instancia\n\nTambién se puede usar decoradores o módulos."}
{"prompt": "Cómo usar async/await en Python.", "response": "async/await permite programación asíncrona. Ejemplo:\nimport asyncio\n\nasync def tarea_lenta():\n    print('Iniciando tarea')\n    await asyncio.sleep(2)\n    print('Tarea completada')\n    return 'Resultado'\n\nasync def main():\n    resultado = await tarea_lenta()\n    print(f'Resultado: {resultado}')\n\n# Ejecutar\nasyncio.run(main())\n\nÚtil para I/O bound operations."}
{"prompt": "Qué son las dataclasses en Python 3.7+.", "response": "Las dataclasses reducen código boilerplate para clases que almacenan datos:\nfrom dataclasses import dataclass\n\n@dataclass\nclass Persona:\n    nombre: str\n    edad: int\n    ciudad: str = 'Desconocida'  # Valor por defecto\n\n# Automáticamente obtienes __init__, __repr__, __eq__\npersona = Persona('Ana', 25)\nprint(persona)  # Persona(nombre='Ana', edad=25, ciudad='Desconocida')"}
{"prompt": "Cómo usar type hints en Python.", "response": "Los type hints ayudan a documentar tipos esperados:\ndef saludar(nombre: str) -> str:\n    return f'Hola {nombre}'\n\n# Tipos complejos\nfrom typing import List, Dict, Optional, Union\n\ndef procesar(\n    numeros: List[int], \n    config: Optional[Dict[str, str]] = None\n) -> Union[int, float]:\n    # Código...\n    return 3.14\n\n# Python no fuerza estos tipos, son para documentación y herramientas."}
{"prompt": "Explica el Garbage Collector en Python.", "response": "Python tiene recolector de basura automático que libera memoria de objetos no referenciados. Usa conteo de referencias principalmente. Ejemplo:\nimport gc\n\n# Deshabilitar temporalmente\ngc.disable()\n# ...código crítico...\ngc.enable()\n\n# Ver estadísticas\nprint(gc.get_stats())\n\n# Forzar recolección\ngc.collect()\n\nGeneralmente no necesitas intervenir manualmente."}
{"prompt": "Cómo optimizar código Python.", "response": "Optimiza primero el algoritmo, luego el código. Consejos:\n1. Usa estructuras de datos apropiadas\n2. Evita bucles anidados cuando sea posible\n3. Usa comprensión de listas\n4. Aprovecha funciones built-in\n5. Usa generators para grandes datos\n6. Perfila con cProfile:\nimport cProfile\ncProfile.run('mi_funcion()')\n\n7. Considera PyPy o Cython para código crítico"}
{"prompt": "Qué es el Zen de Python.", "response": "El Zen de Python son principios de diseño. Verlos con:\nimport this\n\nPrincipios clave:\n- Bello es mejor que feo.\n- Explícito es mejor que implícito.\n- Simple es mejor que complejo.\n- Complejo es mejor que complicado.\n- La legibilidad cuenta.\n- Los errores nunca deben pasar silenciosamente.\n- Hay una, y sólo una, manera obvia de hacerlo.\n- Frente a la ambigüedad, evita la tentación de adivinar."}
{"prompt": "Cómo usar logging en lugar de print.", "response": "Logging es más profesional que print para producción:\nimport logging\n\nlogging.basicConfig(\n    level=logging.DEBUG,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\n\nlogger = logging.getLogger(__name__)\n\nlogger.debug('Mensaje de depuración')\nlogger.info('Información general')\nlogger.warning('Advertencia')\nlogger.error('Error')\nlogger.critical('Crítico')\n\nPuedes configurar salida a archivo, niveles diferentes, etc."}
{"prompt": "Explica las namedtuples en Python.", "response": "Las namedtuples son tuplas con nombres para campos:\nfrom collections import namedtuple\n\nPunto = namedtuple('Punto', ['x', 'y'])\np = Punto(1, 2)\nprint(p.x, p.y)  # 1 2\nprint(p[0])  # También accesible por índice: 1\n\n# Python 3.7+: typed namedtuple\nfrom typing import NamedTuple\n\nclass Coordenada(NamedTuple):\n    x: float\n    y: float\n\nc = Coordenada(1.5, 2.5)\nprint(c)  # Coordenada(x=1.5, y=2.5)"}
{"prompt": "Cómo hacer web scraping básico con Python.", "response": "Usa requests y BeautifulSoup para scraping básico:\nimport requests\nfrom bs4 import BeautifulSoup\n\nurl = 'https://ejemplo.com'\nrespuesta = requests.get(url)\nsoup = BeautifulSoup(respuesta.text, 'html.parser')\n\n# Encontrar todos los títulos h1\ntitulos = soup.find_all('h1')\nfor titulo in titulos:\n    print(titulo.text)\n\n# Encontrar por clase\nelementos = soup.find_all('div', class_='producto')\n\n# Siempre revisa robots.txt y términos del sitio"}
{"prompt": "Qué es la recursividad y cuándo usarla.", "response": "Recursividad es cuando una función se llama a sí misma. Ejemplo clásico: factorial.\ndef factorial(n):\n    if n <= 1:  # Caso base\n        return 1\n    return n * factorial(n - 1)  # Caso recursivo\n\nprint(factorial(5))  # 120\n\nÚtil para problemas con estructura recursiva (árboles, divide y vencerás). Siempre necesita caso base para evitar recursión infinita. Puede ser menos eficiente que iteración."}
{"prompt": "Cómo usar el módulo itertools.", "response": "itertools proporciona iteradores eficientes. Algunos útiles:\nimport itertools\n\n# Combinaciones\ncombinaciones = list(itertools.combinations([1,2,3], 2))  # [(1,2),(1,3),(2,3)]\n\n# Permutaciones\npermutaciones = list(itertools.permutations([1,2,3], 2))\n\n# Producto cartesiano\nproducto = list(itertools.product([1,2], ['a','b']))  # [(1,'a'),(1,'b'),(2,'a'),(2,'b')]\n\n# Ciclo infinito\nfor i in itertools.cycle([1,2,3]):\n    print(i)  # 1,2,3,1,2,3...\n    if i == 3: break"}
{"prompt": "Explica el concepto de Pythonic code.", "response": "Código Pythonic sigue los principios de Python: legible, simple, explícito. Ejemplos:\n\n# NO Pythonic\nfor i in range(len(lista)):\n    print(lista[i])\n\n# Pythonic\nfor elemento in lista:\n    print(elemento)\n\n# NO Pythonic\nif x == True:\n    pass\n\n# Pythonic\nif x:\n    pass\n\nUsa comprensiones, context managers, funciones built-in, sigue PEP 8."}
{"prompt": "Cómo manejar fechas con timezone.", "response": "Usa pytz o zoneinfo (Python 3.9+):\nfrom datetime import datetime\nimport pytz\n\n# Crear datetime con timezone\nutc = pytz.UTC\nfecha_utc = datetime.now(utc)\n\n# Convertir timezones\nmadrid_tz = pytz.timezone('Europe/Madrid')\nfecha_madrid = fecha_utc.astimezone(madrid_tz)\n\n# Python 3.9+:\nfrom zoneinfo import ZoneInfo\nfecha = datetime.now(ZoneInfo('Europe/Madrid'))\n\nSiempre trabaja en UTC internamente, convierte al mostrar."}
{"prompt": "Qué es un decorador con parámetros.", "response": "Un decorador con parámetros necesita una función extra. Ejemplo:\ndef repetir(n_veces):\n    def decorador(func):\n        def wrapper(*args, **kwargs):\n            for _ in range(n_veces):\n                resultado = func(*args, **kwargs)\n            return resultado\n        return wrapper\n    return decorador\n\n@repetir(3)\ndef saludar():\n    print('Hola')\n\nsaludar()  # Imprime 'Hola' 3 veces\n\nPrimero se llama a repetir(3), luego el resultado decora la función."}
{"prompt": "Cómo usar property para getters/setters.", "response": "Property permite métodos que se acceden como atributos:\nclass Persona:\n    def __init__(self, nombre, edad):\n        self._nombre = nombre\n        self._edad = edad\n    \n    @property\n    def nombre(self):\n        return self._nombre\n    \n    @nombre.setter\n    def nombre(self, valor):\n        if not valor:\n            raise ValueError('Nombre no puede estar vacío')\n        self._nombre = valor\n    \n    @property\n    def edad(self):\n        return self._edad\n    \n    @edad.setter\n    def edad(self, valor):\n        if valor < 0:\n            raise ValueError('Edad no puede ser negativa')\n        self._edad = valor"}
{"prompt": "Explica el uso de slots en clases.", "response": "__slots__ optimiza memoria al evitar diccionario __dict__:\nclass Persona:\n    __slots__ = ['nombre', 'edad']\n    \n    def __init__(self, nombre, edad):\n        self.nombre = nombre\n        self.edad = edad\n\n# Ventajas:\n# - Menor uso de memoria\n# - Acceso más rápido a atributos\n\n# Desventajas:\n# - No se pueden agregar atributos dinámicamente\n# - No funciona con herencia múltiple sin slots en padres\n\nÚtil para muchas instancias de clases simples."}
{"prompt": "Cómo implementar una pila (stack) en Python.", "response": "Una pila es LIFO (Last In, First Out). Implementación con lista:\nclass Pila:\n    def __init__(self):\n        self.items = []\n    \n    def apilar(self, item):\n        self.items.append(item)\n    \n    def desapilar(self):\n        if not self.esta_vacia():\n            return self.items.pop()\n        raise IndexError('La pila está vacía')\n    \n    def esta_vacia(self):\n        return len(self.items) == 0\n    \n    def ver_tope(self):\n        if not self.esta_vacia():\n            return self.items[-1]\n        raise IndexError('La pila está vacía')\n\n# Uso\np = Pila()\np.apilar(1)\np.apilar(2)\nprint(p.desapilar())  # 2"}
{"prompt": "Cómo implementar una cola (queue) en Python.", "response": "Una cola es FIFO (First In, First Out). Implementación:\nfrom collections import deque\n\nclass Cola:\n    def __init__(self):\n        self.items = deque()\n    \n    def encolar(self, item):\n        self.items.append(item)\n    \n    def desencolar(self):\n        if not self.esta_vacia():\n            return self.items.popleft()\n        raise IndexError('La cola está vacía')\n    \n    def esta_vacia(self):\n        return len(self.items) == 0\n    \n    def tamano(self):\n        return len(self.items)\n\n# Para cola con prioridad usa heapq\nimport heapq\n\nclass ColaPrioridad:\n    def __init__(self):\n        self.items = []\n    \n    def encolar(self, item, prioridad):\n        heapq.heappush(self.items, (prioridad, item))\n    \n    def desencolar(self):\n        return heapq.heappop(self.items)[1]"}
{"prompt": "Explica el patrón Observer en Python.", "response": "Observer notifica cambios a suscriptores. Implementación:\nclass Sujeto:\n    def __init__(self):\n        self._observadores = []\n    \n    def agregar_observador(self, observador):\n        self._observadores.append(observador)\n    \n    def eliminar_observador(self, observador):\n        self._observadores.remove(observador)\n    \n    def notificar(self, *args, **kwargs):\n        for observador in self._observadores:\n            observador.actualizar(*args, **kwargs)\n\nclass Observador:\n    def actualizar(self, *args, **kwargs):\n        pass\n\n# Ejemplo concreto\nclass TemperaturaSensor(Sujeto):\n    def __init__(self):\n        super().__init__()\n        self._temperatura = 0\n    \n    @property\n    def temperatura(self):\n        return self._temperatura\n    \n    @temperatura.setter\n    def temperatura(self, valor):\n        self._temperatura = valor\n        self.notificar(temperatura=valor)\n\nclass Display(Observador):\n    def actualizar(self, temperatura):\n        print(f'Temperatura actualizada: {temperatura}°C')"}
{"prompt": "Cómo hacer pruebas unitarias con unittest.", "response": "Ejemplo básico de unittest:\nimport unittest\n\ndef suma(a, b):\n    return a + b\n\nclass TestSuma(unittest.TestCase):\n    def test_suma_positivos(self):\n        self.assertEqual(suma(2, 3), 5)\n    \n    def test_suma_negativos(self):\n        self.assertEqual(suma(-2, -3), -5)\n    \n    def test_suma_mezclada(self):\n        self.assertEqual(suma(-5, 5), 0)\n    \n    def test_suma_tipos(self):\n        with self.assertRaises(TypeError):\n            suma('2', 3)\n\n# Ejecutar pruebas\nif __name__ == '__main__':\n    unittest.main()\n\n# También útil: setUp() y tearDown() para preparación/limpieza"}
{"prompt": "Cómo usar pytest para pruebas más simples.", "response": "pytest es más conciso que unittest:\n# test_mi_modulo.py\n\ndef suma(a, b):\n    return a + b\n\ndef test_suma_positivos():\n    assert suma(2, 3) == 5\n\ndef test_suma_negativos():\n    assert suma(-2, -3) == -5\n\ndef test_suma_mezclada():\n    assert suma(-5, 5) == 0\n\n# Ejecutar con: pytest test_mi_modulo.py\n\n# Fixtures para reutilizar código:\nimport pytest\n\n@pytest.fixture\ndef datos_prueba():\n    return {'a': 2, 'b': 3}\n\ndef test_con_fixture(datos_prueba):\n    assert suma(datos_prueba['a'], datos_prueba['b']) == 5"}
{"prompt": "Qué es la inyección de dependencias en Python.", "response": "La inyección de dependencias pasa dependencias desde fuera en lugar de crearlas dentro. Mejora testabilidad y desacoplamiento:\n# SIN inyección\ndef procesar_datos():\n    db = Database()  # Dependencia creada dentro\n    return db.query('SELECT * FROM datos')\n\n# CON inyección\ndef procesar_datos(db):  # Dependencia inyectada\n    return db.query('SELECT * FROM datos')\n\n# Ahora es fácil cambiar la base de datos para pruebas\nclass MockDatabase:\n    def query(self, sql):\n        return [1, 2, 3]\n\n# En producción\ndb_real = Database()\nresultado = procesar_datos(db_real)\n\n# En pruebas\ndb_mock = MockDatabase()\nresultado = procesar_datos(db_mock)\n\n# También se pueden usar frameworks como injector"}
{"prompt": "Cómo usar expresiones regulares en Python.", "response": "El módulo re permite usar regex:\nimport re\n\n# Buscar patrón\ntexto = 'Mi teléfono es 123-456-7890'\npatron = r'\\d{3}-\\d{3}-\\d{4}'\nmatch = re.search(patron, texto)\nif match:\n    print(f'Teléfono encontrado: {match.group()}')  # 123-456-7890\n\n# Encontrar todos\ntexto = 'rojo, verde, azul, rojo'\nmatches = re.findall(r'rojo', texto)\nprint(matches)  # ['rojo', 'rojo']\n\n# Reemplazar\nnuevo_texto = re.sub(r'\\d', 'X', 'A1B2C3')\nprint(nuevo_texto)  # AXBXCX\n\n# Compilar para reutilizar\npatron = re.compile(r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$')\nif patron.match('usuario@ejemplo.com'):\n    print('Email válido')"}
{"prompt": "Explica el patrón Factory en Python.", "response": "El patrón Factory crea objetos sin especificar la clase exacta. Ejemplo:\nfrom abc import ABC, abstractmethod\n\nclass Vehiculo(ABC):\n    @abstractmethod\n    def mover(self):\n        pass\n\nclass Coche(Vehiculo):\n    def mover(self):\n        return 'Conduciendo'\n\nclass Bicicleta(Vehiculo):\n    def mover(self):\n        return 'Pedaleando'\n\nclass FabricaVehiculos:\n    @staticmethod\n    def crear_vehiculo(tipo):\n        if tipo == 'coche':\n            return Coche()\n        elif tipo == 'bicicleta':\n            return Bicicleta()\n        else:\n            raise ValueError(f'Tipo desconocido: {tipo}')\n\n# Uso\nvehiculo = FabricaVehiculos.crear_vehiculo('coche')\nprint(vehiculo.mover())  # Conduciendo"}
{"prompt": "Cómo trabajar con bases de datos SQLite.", "response": "SQLite es una base de datos ligera incluida en Python:\nimport sqlite3\n\n# Conectar (crea archivo si no existe)\nconexion = sqlite3.connect('mi_base.db')\ncursor = conexion.cursor()\n\n# Crear tabla\ncursor.execute('''\n    CREATE TABLE IF NOT EXISTS usuarios (\n        id INTEGER PRIMARY KEY,\n        nombre TEXT NOT NULL,\n        edad INTEGER\n    )\n''')\n\n# Insertar datos\ncursor.execute('INSERT INTO usuarios (nombre, edad) VALUES (?, ?)', ('Ana', 25))\nconexion.commit()\n\n# Consultar datos\ncursor.execute('SELECT * FROM usuarios')\nfilas = cursor.fetchall()\nfor fila in filas:\n    print(fila)\n\n# Cerrar conexión\nconexion.close()\n\n# Para usar con with y manejar errores:\nwith sqlite3.connect('mi_base.db') as conn:\n    cursor = conn.cursor()\n    # operaciones..."}
{"prompt": "Cómo usar SQLAlchemy como ORM.", "response": "SQLAlchemy es un ORM popular. Ejemplo básico:\nfrom sqlalchemy import create_engine, Column, Integer, String\nfrom sqlalchemy.ext.declarative import declarative_base\nfrom sqlalchemy.orm import sessionmaker\n\nBase = declarative_base()\n\nclass Usuario(Base):\n    __tablename__ = 'usuarios'\n    \n    id = Column(Integer, primary_key=True)\n    nombre = Column(String)\n    edad = Column(Integer)\n    \n    def __repr__(self):\n        return f'<Usuario(nombre={self.nombre}, edad={self.edad})>'\n\n# Conectar a base de datos\nengine = create_engine('sqlite:///mi_base.db')\nBase.metadata.create_all(engine)\n\n# Crear sesión\nSession = sessionmaker(bind=engine)\nsession = Session()\n\n# Operaciones CRUD\n# Crear\nnuevo_usuario = Usuario(nombre='Carlos', edad=30)\nsession.add(nuevo_usuario)\nsession.commit()\n\n# Leer\nusuarios = session.query(Usuario).filter_by(edad=30).all()\n\n# Actualizar\nusuario = session.query(Usuario).filter_by(nombre='Carlos').first()\nusuario.edad = 31\nsession.commit()\n\n# Eliminar\nsession.delete(usuario)\nsession.commit()\n\nsession.close()"}
{"prompt": "Cómo crear una API REST con Flask.", "response": "Ejemplo básico de API REST con Flask:\nfrom flask import Flask, request, jsonify\n\napp = Flask(__name__)\n\n# Datos en memoria para ejemplo\nusuarios = [\n    {'id': 1, 'nombre': 'Ana', 'edad': 25},\n    {'id': 2, 'nombre': 'Juan', 'edad': 30}\n]\n\n# GET todos los usuarios\n@app.route('/usuarios', methods=['GET'])\ndef obtener_usuarios():\n    return jsonify(usuarios)\n\n# GET usuario específico\n@app.route('/usuarios/<int:usuario_id>', methods=['GET'])\ndef obtener_usuario(usuario_id):\n    usuario = next((u for u in usuarios if u['id'] == usuario_id), None)\n    if usuario:\n        return jsonify(usuario)\n    return jsonify({'error': 'Usuario no encontrado'}), 404\n\n# POST crear usuario\n@app.route('/usuarios', methods=['POST'])\ndef crear_usuario():\n    datos = request.get_json()\n    nuevo_id = max([u['id'] for u in usuarios]) + 1 if usuarios else 1\n    nuevo_usuario = {\n        'id': nuevo_id,\n        'nombre': datos['nombre'],\n        'edad': datos['edad']\n    }\n    usuarios.append(nuevo_usuario)\n    return jsonify(nuevo_usuario), 201\n\n# PUT actualizar usuario\n@app.route('/usuarios/<int:usuario_id>', methods=['PUT'])\ndef actualizar_usuario(usuario_id):\n    usuario = next((u for u in usuarios if u['id'] == usuario_id), None)\n    if not usuario:\n        return jsonify({'error': 'Usuario no encontrado'}), 404\n    \n    datos = request.get_json()\n    usuario.update({\n        'nombre': datos.get('nombre', usuario['nombre']),\n        'edad': datos.get('edad', usuario['edad'])\n    })\n    return jsonify(usuario)\n\n# DELETE usuario\n@app.route('/usuarios/<int:usuario_id>', methods=['DELETE'])\ndef eliminar_usuario(usuario_id):\n    global usuarios\n    usuarios = [u for u in usuarios if u['id'] != usuario_id]\n    return '', 204\n\nif __name__ == '__main__':\n    app.run(debug=True)"}
{"prompt": "Cómo crear una API REST con FastAPI.", "response": "FastAPI es más moderno y rápido. Ejemplo básico:\nfrom fastapi import FastAPI, HTTPException\nfrom pydantic import BaseModel\nfrom typing import List, Optional\n\napp = FastAPI()\n\n# Modelo de datos\nclass Usuario(BaseModel):\n    id: int\n    nombre: str\n    edad: int\n    email: Optional[str] = None\n\nclass UsuarioCrear(BaseModel):\n    nombre: str\n    edad: int\n    email: Optional[str] = None\n\n# Datos en memoria\nusuarios_db = [\n    Usuario(id=1, nombre='Ana', edad=25, email='ana@email.com'),\n    Usuario(id=2, nombre='Juan', edad=30, email='juan@email.com')\n]\n\n# GET todos\n@app.get('/usuarios', response_model=List[Usuario])\ndef obtener_usuarios():\n    return usuarios_db\n\n# GET por ID\n@app.get('/usuarios/{usuario_id}', response_model=Usuario)\ndef obtener_usuario(usuario_id: int):\n    usuario = next((u for u in usuarios_db if u.id == usuario_id), None)\n    if not usuario:\n        raise HTTPException(status_code=404, detail='Usuario no encontrado')\n    return usuario\n\n# POST crear\n@app.post('/usuarios', response_model=Usuario, status_code=201)\ndef crear_usuario(usuario: UsuarioCrear):\n    nuevo_id = max([u.id for u in usuarios_db]) + 1 if usuarios_db else 1\n    nuevo_usuario = Usuario(\n        id=nuevo_id,\n        nombre=usuario.nombre,\n        edad=usuario.edad,\n        email=usuario.email\n    )\n    usuarios_db.append(nuevo_usuario)\n    return nuevo_usuario\n\n# PUT actualizar\n@app.put('/usuarios/{usuario_id}', response_model=Usuario)\ndef actualizar_usuario(usuario_id: int, usuario_actualizado: UsuarioCrear):\n    for i, usuario in enumerate(usuarios_db):\n        if usuario.id == usuario_id:\n            usuarios_db[i] = Usuario(\n                id=usuario_id,\n                nombre=usuario_actualizado.nombre,\n                edad=usuario_actualizado.edad,\n                email=usuario_actualizado.email\n            )\n            return usuarios_db[i]\n    raise HTTPException(status_code=404, detail='Usuario no encontrado')\n\n# DELETE\n@app.delete('/usuarios/{usuario_id}', status_code=204)\ndef eliminar_usuario(usuario_id: int):\n    for i, usuario in enumerate(usuarios_db):\n        if usuario.id == usuario_id:\n            usuarios_db.pop(i)\n            return\n    raise HTTPException(status_code=404, detail='Usuario no encontrado')\n\n# Ejecutar: uvicorn main:app --reload"}
{"prompt": "Cómo usar Jupyter Notebook para análisis de datos.", "response": "Jupyter Notebook es ideal para análisis exploratorio:\n\n1. Instalación:\npip install jupyter\n\n2. Ejecutar:\njupyter notebook\n\n3. Celdas útiles:\n\n# Celda de código\nimport pandas as pd\nimport numpy as np\nimport matplotlib.pyplot as plt\n%matplotlib inline\n\n# Cargar datos\ndf = pd.read_csv('datos.csv')\n\n# Explorar\ndf.head()\ndf.info()\ndf.describe()\n\n# Visualizar\ndf['columna'].hist()\ndf.plot.scatter(x='col1', y='col2')\n\n# Análisis\ncorrelacion = df.corr()\n\n# Celda markdown para documentación\n# # Título\n# ## Subtítulo\n# - Lista\n# - Elementos\n\n# Celda mágica para tiempo\n%%time\n# código a medir\n\n# Celda para depurar\n%debug\n\n# Exportar a diferentes formatos\n# Archivo > Descargar como > PDF/HTML/Python\n\n# Atajos útiles:\n# Shift+Enter: Ejecutar celda\n# Esc: Modo comando\n# A: Insertar celda arriba\n# B: Insertar celda abajo\n# DD: Eliminar celda\n# M: Convertir a markdown\n# Y: Convertir a código"}
{"prompt": "Cómo usar pandas para análisis de datos.", "response": "Pandas es esencial para análisis de datos en Python:\n\nimport pandas as pd\nimport numpy as np\n\n# Crear DataFrame\ndata = {\n    'Nombre': ['Ana', 'Juan', 'Luis'],\n    'Edad': [25, 30, 35],\n    'Ciudad': ['Madrid', 'Barcelona', 'Valencia']\n}\ndf = pd.DataFrame(data)\n\n# Operaciones básicas\nprint(df.head())  # Primeras filas\nprint(df.info())  # Información\nprint(df.describe())  # Estadísticas\n\n# Selección\ndf['Nombre']  # Columna\ndf[['Nombre', 'Edad']]  # Múltiples columnas\ndf.iloc[0]  # Fila por índice\n\n# Filtrado\ndf[df['Edad'] > 28]  # Filas con edad > 28\ndf[(df['Edad'] > 28) & (df['Ciudad'] == 'Barcelona')]\n\n# Agregación\ndf.groupby('Ciudad')['Edad'].mean()  # Edad promedio por ciudad\ndf['Edad'].sum()  # Suma total\n\n# Valores faltantes\ndf.isnull().sum()  # Contar nulos\ndf.dropna()  # Eliminar filas con nulos\ndf.fillna(0)  # Rellenar nulos con 0\n\n# Ordenar\ndf.sort_values('Edad', ascending=False)\n\n# Nuevas columnas\ndf['Edad_en_10'] = df['Edad'] + 10\n\n# Unir DataFrames\ndf1.merge(df2, on='columna_comun')\npd.concat([df1, df2])\n\n# Leer/escribir archivos\ndf = pd.read_csv('datos.csv')\ndf.to_csv('salida.csv', index=False)\n# También read_excel, read_json, read_sql"}
{"prompt": "Cómo visualizar datos con matplotlib y seaborn.", "response": "Matplotlib para gráficos básicos, Seaborn para estadísticos:\n\nimport matplotlib.pyplot as plt\nimport seaborn as sns\nimport pandas as pd\n\n# Datos de ejemplo\ndf = pd.DataFrame({\n    'Mes': ['Ene', 'Feb', 'Mar', 'Abr', 'May'],\n    'Ventas': [100, 120, 90, 150, 130],\n    'Categoria': ['A', 'A', 'B', 'B', 'A']\n})\n\n# Matplotlib básico\nplt.figure(figsize=(10, 6))\nplt.plot(df['Mes'], df['Ventas'], marker='o', label='Ventas')\nplt.title('Ventas por Mes')\nplt.xlabel('Mes')\nplt.ylabel('Ventas')\nplt.legend()\nplt.grid(True, alpha=0.3)\nplt.tight_layout()\nplt.show()\n\n# Varios tipos de gráficos\nfig, axes = plt.subplots(2, 2, figsize=(12, 10))\n\n# Gráfico de barras\naxes[0, 0].bar(df['Mes'], df['Ventas'])\naxes[0, 0].set_title('Barras')\n\n# Histograma\naxes[0, 1].hist(df['Ventas'], bins=10, edgecolor='black')\naxes[0, 1].set_title('Histograma')\n\n# Scatter\naxes[1, 0].scatter(df['Mes'], df['Ventas'], s=100)\naxes[1, 0].set_title('Scatter')\n\n# Pie chart\naxes[1, 1].pie(df['Ventas'], labels=df['Mes'], autopct='%1.1f%%')\naxes[1, 1].set_title('Pastel')\n\nplt.tight_layout()\nplt.show()\n\n# Seaborn para mejores gráficos estadísticos\nsns.set_style('whitegrid')\n\n# Gráfico con categorías\nplt.figure(figsize=(10, 6))\nsns.barplot(x='Mes', y='Ventas', hue='Categoria', data=df)\nplt.title('Ventas por Mes y Categoría')\nplt.show()\n\n# Boxplot\nsns.boxplot(x='Categoria', y='Ventas', data=df)\n\n# Pairplot para múltiples variables\n# sns.pairplot(df, hue='Categoria')\n\n# Heatmap de correlación\n# correlacion = df.corr()\n# sns.heatmap(correlacion, annot=True, cmap='coolwarm')\n\n# Personalización global\nplt.rcParams['font.size'] = 12\nplt.rcParams['figure.figsize'] = (10, 6)"}
{"prompt": "Cómo hacer machine learning básico con scikit-learn.", "response": "Scikit-learn hace ML accesible. Ejemplo completo:\n\nimport numpy as np\nimport pandas as pd\nfrom sklearn.model_selection import train_test_split\nfrom sklearn.preprocessing import StandardScaler\nfrom sklearn.linear_model import LogisticRegression\nfrom sklearn.metrics import accuracy_score, classification_report, confusion_matrix\nimport seaborn as sns\nimport matplotlib.pyplot as plt\n\n# 1. Cargar datos (ejemplo: Iris dataset)\nfrom sklearn.datasets import load_iris\niris = load_iris()\nX = iris.data\ny = iris.target\nfeature_names = iris.feature_names\ntarget_names = iris.target_names\n\nprint(f'Forma de X: {X.shape}')\nprint(f'Clases: {target_names}')\n\n# 2. Dividir en entrenamiento y prueba\nX_train, X_test, y_train, y_test = train_test_split(\n    X, y, test_size=0.2, random_state=42, stratify=y\n)\n\nprint(f'Entrenamiento: {X_train.shape[0]} muestras')\nprint(f'Prueba: {X_test.shape[0]} muestras')\n\n# 3. Escalar características (importante para muchos algoritmos)\nscaler = StandardScaler()\nX_train_scaled = scaler.fit_transform(X_train)\nX_test_scaled = scaler.transform(X_test)\n\n# 4. Entrenar modelo\nmodelo = LogisticRegression(random_state=42, max_iter=200)\nmodelo.fit(X_train_scaled, y_train)\n\n# 5. Predecir\ny_pred = modelo.predict(X_test_scaled)\ny_pred_proba = modelo.predict_proba(X_test_scaled)\n\n# 6. Evaluar\naccuracy = accuracy_score(y_test, y_pred)\nprint(f'\\nExactitud: {accuracy:.2f}')\n\nprint('\\nReporte de clasificación:')\nprint(classification_report(y_test, y_pred, target_names=target_names))\n\n# Matriz de confusión\ncm = confusion_matrix(y_test, y_pred)\nplt.figure(figsize=(8, 6))\nsns.heatmap(cm, annot=True, fmt='d', cmap='Blues', \n            xticklabels=target_names, yticklabels=target_names)\nplt.title('Matriz de Confusión')\nplt.ylabel('Verdadero')\nplt.xlabel('Predicho')\nplt.show()\n\n# 7. Importancia de características\nif hasattr(modelo, 'coef_'):\n    importancia = np.abs(modelo.coef_[0])\n    plt.figure(figsize=(10, 4))\n    plt.bar(range(len(importancia)), importancia)\n    plt.xticks(range(len(importancia)), feature_names, rotation=45)\n    plt.title('Importancia de Características')\n    plt.show()\n\n# 8. Guardar modelo\nimport joblib\njoblib.dump(modelo, 'modelo_iris.pkl')\njoblib.dump(scaler, 'scaler_iris.pkl')\n\n# 9. Cargar y usar modelo guardado\n# modelo_cargado = joblib.load('modelo_iris.pkl')\n# scaler_cargado = joblib.load('scaler_iris.pkl')\n# nueva_muestra = [[5.1, 3.5, 1.4, 0.2]]\n# nueva_muestra_scaled = scaler_cargado.transform(nueva_muestra)\n# prediccion = modelo_cargado.predict(nueva_muestra_scaled)\n# print(f'Predicción: {target_names[prediccion[0]]}')"}
{"prompt": "Cómo hacer web scraping dinámico con Selenium.", "response": "Selenium automatiza navegadores para scraping de páginas dinámicas:\n\nfrom selenium import webdriver\nfrom selenium.webdriver.common.by import By\nfrom selenium.webdriver.common.keys import Keys\nfrom selenium.webdriver.support.ui import WebDriverWait\nfrom selenium.webdriver.support import expected_conditions as EC\nimport time\n\n# Configurar driver (necesitas descargar chromedriver)\n# Opción 1: Con path explícito\ndriver = webdriver.Chrome(executable_path='/ruta/chromedriver')\n\n# Opción 2: Si chromedriver está en PATH\ndriver = webdriver.Chrome()\n\n# Opción 3: Headless (sin interfaz gráfica)\nfrom selenium.webdriver.chrome.options import Options\n\nchrome_options = Options()\nchrome_options.add_argument('--headless')  # Ejecutar sin UI\nchrome_options.add_argument('--no-sandbox')\nchrome_options.add_argument('--disable-dev-shm-usage')\ndriver = webdriver.Chrome(options=chrome_options)\n\ntry:\n    # Navegar a página\ndriver.get('https://www.ejemplo.com')\n    \n    # Esperar a que elemento cargue\nwait = WebDriverWait(driver, 10)\nelemento = wait.until(EC.presence_of_element_located((By.ID, 'mi-elemento')))\n    \n    # Encontrar elementos\n# Por ID\nelemento = driver.find_element(By.ID, 'campo-busqueda')\n    \n# Por nombre\nelemento = driver.find_element(By.NAME, 'q')\n    \n# Por clase\nelementos = driver.find_elements(By.CLASS_NAME, 'producto')\n    \n# Por selector CSS\nelemento = driver.find_element(By.CSS_SELECTOR, 'div.contenido > h1')\n    \n# Por XPath (útil para navegar DOM)\nelemento = driver.find_element(By.XPATH, '//div[@id=\"contenido\"]/p[1]')\n    \n    # Interactuar con elementos\n# Escribir texto\nelemento.send_keys('Python tutorial')\n    \n# Hacer click\nelemento.click()\n    \n# Presionar Enter\nelemento.send_keys(Keys.RETURN)\n    \n# Seleccionar dropdown\nfrom selenium.webdriver.support.ui import Select\nselect = Select(driver.find_element(By.ID, 'mi-select'))\nselect.select_by_visible_text('Opción 2')\n    \n    # Capturar datos\n# Texto\ntexto = elemento.text\n    \n# Atributos\nhref = elemento.get_attribute('href')\n    \n# Tomar screenshot\ndriver.save_screenshot('pagina.png')\n    \n    # JavaScript\nresultado = driver.execute_script('return document.title')\ndriver.execute_script('window.scrollTo(0, document.body.scrollHeight);')\n    \n    # Manejar múltiples ventanas/pestañas\ndriver.switch_to.window(driver.window_handles[1])  # Cambiar a segunda pestaña\n    \n    # Cookies\ncookies = driver.get_cookies()\nfor cookie in cookies:\n    print(f'{cookie[\"name\"]}: {cookie[\"value\"]}')\n    \n    # Agregar cookie\ndriver.add_cookie({'name': 'test', 'value': '123'})\n    \n    # Ejemplo completo: buscar en Google\n    driver.get('https://www.google.com')\n    \n    # Aceptar cookies si existe\n    try:\n        aceptar_btn = driver.find_element(By.ID, 'L2AGLb')\n        aceptar_btn.click()\n    except:\n        pass\n    \n    # Buscar\n    search_box = driver.find_element(By.NAME, 'q')\n    search_box.send_keys('Python Selenium tutorial')\n    search_box.send_keys(Keys.RETURN)\n    \n    # Esperar resultados\n    time.sleep(2)\n    \n    # Capturar primeros resultados\n    resultados = driver.find_elements(By.CSS_SELECTOR, 'div.g')\n    for i, resultado in enumerate(resultados[:5], 1):\n        try:\n            titulo = resultado.find_element(By.CSS_SELECTOR, 'h3').text\n            link = resultado.find_element(By.CSS_SELECTOR, 'a').get_attribute('href')\n            print(f'{i}. {titulo}\\n   {link}\\n')\n        except:\n            continue\n    \nfinally:\n    # Cerrar driver\n    driver.quit()\n\n# Notas importantes:\n# 1. Respeta robots.txt y términos del sitio\n# 2. Agrega delays (time.sleep) para no sobrecargar servidores\n# 3. Usa User-Agents realistas\n# 4. Considera usar proxies para evitar bloqueos\n# 5. Para sitios complejos, considera alternativas como Playwright"}
{"prompt": "Cómo crear un chatbot simple en Python.", "response": "Chatbot simple con procesamiento básico de lenguaje:\n\nimport random\nimport re\nfrom datetime import datetime\n\nclass ChatbotSimple:\n    def __init__(self, nombre='Asistente'):\n        self.nombre = nombre\n        self.contexto = {}\n        \n        # Patrones de respuesta\n        self.patrones = [\n            (r'Hola|Hola!|Hey', ['¡Hola!', '¡Hola! ¿Cómo estás?', '¡Buenos días!']),\n            (r'¿Cómo estás\\??|Cómo estás', ['Muy bien, gracias por preguntar.', 'Excelente, ¿y tú?']),\n            (r'¿Cuál es tu nombre\\??|Cómo te llamas', [f'Me llamo {self.nombre}', f'Soy {self.nombre}, tu asistente virtual.']),\n            (r'¿Qué hora es\\??|Hora', self.obtener_hora),\n            (r'Adiós|Chao|Hasta luego', ['¡Adiós!', '¡Hasta luego!', 'Que tengas un buen día.']),\n            (r'gracias|te agradezco', ['De nada.', '¡Con gusto!', 'Feliz de ayudar.']),\n            (r'\\b(?:dime|cuéntame)\\s+.*\\b(chiste|chistes)\\b', self.contar_chiste),\n            (r'\\b(suma|resta|multiplica|divide)\\b.*\\b(\\d+)\\b.*\\b(\\d+)\\b', self.calcular),\n            (r'\\b(clima|tiempo)\\b.*\\b(\\w+)\\b', self.clima_ficticio),\n        ]\n        \n        # Respuestas por defecto\n        self.respuestas_default = [\n            'No estoy seguro de entender. ¿Podrías reformular?',\n            'Interesante, ¿puedes contarme más?',\n            'No tengo información sobre eso todavía.',\n            '¿Qué más te gustaría saber?'\n        ]\n        \n    def obtener_hora(self):\n        ahora = datetime.now()\n        return [f'Son las {ahora.strftime(\"%H:%M\")}', f'La hora actual es {ahora.strftime(\"%H:%M\")}']\n    \n    def contar_chiste(self):\n        chistes = [\n            '¿Por qué los programadores prefieren el frío? ¡Porque no hay bugs en invierno!',\n            '¿Qué le dice un bit al otro? Nos vemos en el bus.',\n            '¿Cómo se dice campo de árboles binarios en inglés? Trie.',\n            '¿Por qué el programador cruzó la calle? Para llegar al otro byte.'\n        ]\n        return [random.choice(chistes)]\n    \n    def calcular(self, match):\n        operacion = match.group(1)\n        num1 = int(match.group(2))\n        num2 = int(match.group(3))\n        \n        if operacion == 'suma':\n            resultado = num1 + num2\n            return [f'{num1} + {num2} = {resultado}']\n        elif operacion == 'resta':\n            resultado = num1 - num2\n            return [f'{num1} - {num2} = {resultado}']\n        elif operacion == 'multiplica':\n            resultado = num1 * num2\n            return [f'{num1} × {num2} = {resultado}']\n        elif operacion == 'divide' and num2 != 0:\n            resultado = num1 / num2\n            return [f'{num1} ÷ {num2} = {resultado:.2f}']\n        else:\n            return ['No puedo realizar esa operación.']\n    \n    def clima_ficticio(self, match):\n        ciudad = match.group(2)\n        climas = ['soleado', 'nublado', 'lluvioso', 'ventoso']\n        temperaturas = {\n            'Madrid': random.randint(15, 30),\n            'Barcelona': random.randint(18, 28),\n            'Valencia': random.randint(20, 32),\n            'default': random.randint(10, 25)\n        }\n        \n        temp = temperaturas.get(ciudad, temperaturas['default'])\n        clima = random.choice(climas)\n        return [f'En {ciudad} hace {temp}°C y está {clima}.']\n    \n    def responder(self, mensaje):\n        # Normalizar mensaje\n        mensaje = mensaje.lower().strip()\n        \n        # Buscar patrón que coincida\n        for patron, respuestas in self.patrones:\n            match = re.search(patron, mensaje, re.IGNORECASE)\n            if match:\n                if callable(respuestas):\n                    return random.choice(respuestas(match))\n                else:\n                    return random.choice(respuestas)\n        \n        # Respuesta por defecto\n        return random.choice(self.respuestas_default)\n    \n    def iniciar_conversacion(self):\n        print(f'{self.nombre}: ¡Hola! Soy {self.nombre}. Puedes preguntarme sobre la hora, chistes, cálculos simples, o el clima de algunas ciudades. Escribe \"adiós\" para terminar.')\n        \n        while True:\n            try:\n                entrada = input('Tú: ')\n                if entrada.lower() in ['adiós', 'chao', 'salir', 'exit']:\n                    print(f'{self.nombre}: ¡Hasta luego! Ha sido un placer ayudarte.')\n                    break\n                \n                respuesta = self.responder(entrada)\n                print(f'{self.nombre}: {respuesta}')\n                \n            except KeyboardInterrupt:\n                print(f'\\n{self.nombre}: ¡Hasta pronto!')\n                break\n            except Exception as e:\n                print(f'{self.nombre}: Lo siento, ha ocurrido un error: {e}')\n\n# Ejecutar el chatbot\nif __name__ == '__main__':\n    bot = ChatbotSimple('PyBot')\n    bot.iniciar_conversacion()\n\n# Para chatbot más avanzado considera:\n# 1. NLTK o spaCy para NLP\n# 2. Rasa o Dialogflow para frameworks completos\n# 3. Integración con APIs\n# 4. Base de conocimiento\n# 5. Machine learning para mejorar respuestas"}
{"prompt": "Cómo optimizar el rendimiento de código Python.", "response": "Estrategias para optimizar Python:\n\n1. **PERFILAR PRIMERO** (nunca optimices sin medir):\nimport cProfile\nimport pstats\n\ndef funcion_lenta():\n    total = 0\n    for i in range(1000000):\n        total += i * i\n    return total\n\n# Perfilar\nprofiler = cProfile.Profile()\nprofiler.enable()\nfuncion_lenta()\nprofiler.disable()\n\nstats = pstats.Stats(profiler)\nstats.sort_stats('cumulative')\nstats.print_stats(10)  # Top 10 funciones\n\n2. **ALGORITMOS Y ESTRUCTURAS DE DATOS** (lo más importante):\n# Usa estructuras apropiadas:\n# - Sets para membership testing O(1)\n# - Dicts para lookups por clave\n# - Listas para secuencias ordenadas\n# - deque para colas\n\n3. **BUILT-IN FUNCTIONS** (implementadas en C):\n# MAL: suma manual\nsuma = 0\nfor num in lista:\n    suma += num\n\n# BIEN: función built-in\nsuma = sum(lista)\n\n4. **COMPRENSIÓN DE LISTAS** (más rápido que for + append):\n# MAL\nresultado = []\nfor i in range(1000):\n    if i % 2 == 0:\n        resultado.append(i * 2)\n\n# BIEN\nresultado = [i * 2 for i in range(1000) if i % 2 == 0]\n\n5. **GENERADORES** para grandes datasets:\n# MAL: lista grande en memoria\ndef leer_archivo_grande():\n    with open('grande.txt') as f:\n        return f.readlines()  # Todo en memoria\n\n# BIEN: generador\ndef leer_archivo_grande():\n    with open('grande.txt') as f:\n        for linea in f:\n            yield linea  # Una línea a la vez\n\n6. **LOCAL VARIABLES** son más rápidas:\ndef funcion_optimizada():\n    local_sum = sum  # Guardar referencia local\n    local_range = range\n    return local_sum(i for i in local_range(1000000))\n\n7. **EVITAR DOT ACCESS** en bucles intensivos:\n# MAL\nimport math\ndef calcular():\n    resultados = []\n    for i in range(1000000):\n        resultados.append(math.sqrt(i))  # Acceso a math.sqrt cada vez\n    return resultados\n\n# BIEN\nimport math\ndef calcular():\n    sqrt = math.sqrt  # Referencia local\n    resultados = []\n    for i in range(1000000):\n        resultados.append(sqrt(i))  # Acceso a variable local\n    return resultados\n\n8. **NUMPY** para cálculos numéricos:\nimport numpy as np\n\n# MAL: Python puro\ndef suma_python(lista1, lista2):\n    resultado = []\n    for a, b in zip(lista1, lista2):\n        resultado.append(a + b)\n    return resultado\n\n# BIEN: NumPy\narray1 = np.array(lista1)\narray2 = np.array(lista2)\nresultado = array1 + array2  # Operación vectorizada\n\n9. **MEMORYVIEW** para arrays grandes:\nimport array\n\ndata = array.array('d', range(1000000))\n# memoryview permite acceso sin copia\nmv = memoryview(data)\nslice_view = mv[1000:2000]\n\n10. **PYTHON OPTIMIZADO**: PyPy para código intensivo CPU, Cython para partes críticas.\n\n11. **CONCURRENCIA**:\n# I/O bound: asyncio\nimport asyncio\n\nasync def tarea_io():\n    await asyncio.sleep(1)\n    return 'Hecho'\n\n# CPU bound: multiprocessing\nfrom multiprocessing import Pool\n\ndef proceso_intensivo(num):\n    return num * num\n\nif __name__ == '__main__':\n    with Pool() as pool:\n        resultados = pool.map(proceso_intensivo, range(1000))\n\n12. **CACHE RESULTS**:\nfrom functools import lru_cache\n\n@lru_cache(maxsize=128)\ndef fibonacci(n):\n    if n < 2:\n        return n\n    return fibonacci(n-1) + fibonacci(n-2)\n\n13. **STRING BUILDER PATTERN**:\n# MAL: concatenación en bucle\nresultado = ''\nfor palabra in lista_palabras:\n    resultado += palabra  # Nuevo string cada vez\n\n# BIEN: join\nresultado = ''.join(lista_palabras)\n\n14. **PROFILER DE MEMORIA**:\n# pip install memory_profiler\nfrom memory_profiler import profile\n\n@profile\ndef funcion_con_memoria():\n    lista_grande = [i for i in range(1000000)]\n    return sum(lista_grande)\n\n15. **COMPILACIÓN JIT**: Numba para funciones numéricas:\n# pip install numba\nfrom numba import jit\nimport numpy as np\n\n@jit(nopython=True)\ndef suma_numpy(arr):\n    total = 0.0\n    for i in range(arr.shape[0]):\n        total += arr[i]\n    return total\n\narr = np.random.random(1000000)\nprint(suma_numpy(arr))\n\n# Regla general: Primero hazlo funcionar, luego hazlo correcto, finalmente hazlo rápido."}
{"prompt": "Cómo empaquetar y distribuir una aplicación Python.", "response": "Guía para empaquetar y distribuir:\n\n1. **ESTRUCTURA DE PROYECTO**:\nmi_proyecto/\n├── pyproject.toml          # Configuración principal (moderno)\n├── setup.py               # Configuración tradicional (legacy)\n├── setup.cfg              # Configuración adicional\n├── MANIFEST.in            # Archivos adicionales a incluir\n├── README.md\n├── LICENSE\n├── src/\n│   └── mi_paquete/\n│       ├── __init__.py\n│       ├── modulo.py\n│       └── datos/\n│           └── datos.json\n├── tests/\n│   ├── __init__.py\n│   └── test_modulo.py\n├── docs/\n│   └── index.md\n└── examples/\n    └── ejemplo_uso.py\n\n2. **PYPROJECT.TOML** (recomendado para proyectos nuevos):\n[build-system]\nrequires = [\"setuptools>=61.0\", \"wheel\"]\nbuild-backend = \"setuptools.build_meta\"\n\n[project]\nname = \"mi-paquete\"\nversion = \"1.0.0\"\nauthors = [\n  {name = \"Tu Nombre\", email = \"tu@email.com\"},\n]\ndescription = \"Descripción breve del paquete\"\nreadme = \"README.md\"\nlicense = {text = \"MIT\"}\nrequires-python = \">=3.8\"\nclassifiers = [\n  \"Programming Language :: Python :: 3\",\n  \"License :: OSI Approved :: MIT License\",\n  \"Operating System :: OS Independent\",\n]\n\n[project.urls]\n\"Homepage\" = \"https://github.com/usuario/mi-paquete\"\n\"Bug Tracker\" = \"https://github.com/usuario/mi-paquete/issues\"\n\n[project.optional-dependencies]\ndev = [\"pytest>=7.0\", \"black>=22.0\"]\n\n[tool.setuptools.packages.find]\nwhere = [\"src\"]\n\n3. **SETUP.PY** (alternativa tradicional):\nfrom setuptools import setup, find_packages\n\nsetup(\n    name='mi-paquete',\n    version='1.0.0',\n    author='Tu Nombre',\n    author_email='tu@email.com',\n    description='Descripción del paquete',\n    long_description=open('README.md').read(),\n    long_description_content_type='text/markdown',\n    url='https://github.com/usuario/mi-paquete',\n    packages=find_packages(where='src'),\n    package_dir={'': 'src'},\n    classifiers=[\n        'Programming Language :: Python :: 3',\n        'License :: OSI Approved :: MIT License',\n        'Operating System :: OS Independent',\n    ],\n    python_requires='>=3.8',\n    install_requires=[\n        'requests>=2.28',\n        'numpy>=1.21',\n    ],\n    extras_require={\n        'dev': ['pytest>=7.0', 'black>=22.0'],\n    },\n    include_package_data=True,\n)\n\n4. **MANIFEST.IN** para archivos no-Python:\ninclude LICENSE\ninclude README.md\ninclude requirements.txt\nrecursive-include src/mi_paquete/datos *.json\nrecursive-include docs *.md\n\n5. **CREAR DISTRIBUCIONES**:\n# Instalar herramientas\npip install build twine\n\n# Crear distribuciones\npython -m build\n\n# Verificar\npython -m twine check dist/*\n\n# Resultado en dist/:\n# mi-paquete-1.0.0.tar.gz       (sdist)\n# mi_paquete-1.0.0-py3-none-any.whl  (wheel)\n\n6. **PUBLICAR EN PyPI**:\n# Primero: Crear cuenta en https://pypi.org\n\n# Subir a PyPI (producción)\ntwine upload dist/*\n\n# O a TestPyPI (para pruebas)\ntwine upload --repository testpypi dist/*\n\n# Instalar desde PyPI\npip install mi-paquete\n\n# Instalar con dependencias opcionales\npip install \"mi-paquete[dev]\"\n\n7. **ENTORNOS AISLADOS PARA DESARROLLO**:\n# Crear entorno virtual\npython -m venv venv\nsource venv/bin/activate  # Linux/Mac\n# venv\\Scripts\\activate   # Windows\n\n# Instalar en modo desarrollo\npip install -e .\n\n# Con dependencias de desarrollo\npip install -e \".[dev]\"\n\n8. **CONTROL DE VERSIONES**:\n# .gitignore típico\n__pycache__/\n*.py[cod]\n*$py.class\n*.so\n.Python\nbuild/\ndist/\n*.egg-info/\nvenv/\nenv/\n*.env\n\n9. **PRUEBAS**:\n# Ejecutar pruebas\npytest\n\n# Con cobertura\npytest --cov=src/mi_paquete\n\n10. **DOCUMENTACIÓN AUTOMÁTICA** (Sphinx):\n# Instalar\npip install sphinx\n\n# Configurar\nsphinx-quickstart docs\n\n# Generar\ncd docs && make html\n\n11. **CI/CD CON GITHUB ACTIONS**:\n# .github/workflows/test.yml\nname: Tests\n\non: [push, pull_request]\n\njobs:\n  test:\n    runs-on: ubuntu-latest\n    strategy:\n      matrix:\n        python-version: [\"3.8\", \"3.9\", \"3.10\", \"3.11\"]\n    \n    steps:\n    - uses: actions/checkout@v3\n    - name: Set up Python ${{ matrix.python-version }}\n      uses: actions/setup-python@v4\n      with:\n        python-version: ${{ matrix.python-version }}\n    - name: Install dependencies\n      run: |\n        python -m pip install --upgrade pip\n        pip install -e \".[dev]\"\n    - name: Run tests\n      run: |\n        pytest\n\n12. **DOCKERIZAR APLICACIÓN**:\n# Dockerfile\nFROM python:3.10-slim\n\nWORKDIR /app\n\nCOPY pyproject.toml .\nRUN pip install --no-cache-dir .\n\nCOPY . .\n\nCMD [\"python\", \"app.py\"]\n\n13. **COMANDOS PERSONALIZADOS**:\n# setup.cfg o setup.py\n[options.entry_points]\nconsole_scripts =\n    mi-comando = mi_paquete.cli:main\n\n# Ahora usuarios pueden ejecutar: mi-comando\n\n14. **VERSIONAMIENTO SEMÁNTICO**:\nMAJOR.MINOR.PATCH\n1.0.0\n- MAJOR: cambios incompatibles\n- MINOR: nuevas características compatibles\n- PATCH: correcciones de bugs compatibles\n\n15. **VERIFICACIONES FINALES**:\n# Check lista\n- [ ] Tests pasan\n- [ ] Versión actualizada\n- [ ] CHANGELOG actualizado\n- [ ] README actualizado\n- [ ] License incluida\n- [ ] .gitignore correcto\n- [ ] No hay credenciales en código\n- [ ] Dependencias actualizadas"}
{"prompt": "Cómo usar Python para automatización de tareas.", "response": "Python es excelente para automatización. Ejemplos prácticos:\n\n1. **AUTOMATIZACIÓN DE ARCHIVOS**:\nimport os\nimport shutil\nfrom pathlib import Path\nimport datetime\n\n# Organizar archivos por extensión\ndef organizar_descargas(ruta_descargas):\n    ruta = Path(ruta_descargas)\n    categorias = {\n        'Imagenes': ['.jpg', '.jpeg', '.png', '.gif'],\n        'Documentos': ['.pdf', '.docx', '.txt', '.xlsx'],\n        'Videos': ['.mp4', '.avi', '.mov'],\n        'Musica': ['.mp3', '.wav'],\n        'Programas': ['.exe', '.msi'],\n    }\n    \n    for archivo in ruta.iterdir():\n        if archivo.is_file():\n            extension = archivo.suffix.lower()\n            encontrado = False\n            \n            for categoria, extensiones in categorias.items():\n                if extension in extensiones:\n                    carpeta_destino = ruta / categoria\n                    carpeta_destino.mkdir(exist_ok=True)\n                    shutil.move(str(archivo), str(carpeta_destino / archivo.name))\n                    encontrado = True\n                    print(f'Movido: {archivo.name} -> {categoria}')\n                    break\n            \n            if not encontrado:\n                carpeta_otros = ruta / 'Otros'\n                carpeta_otros.mkdir(exist_ok=True)\n                shutil.move(str(archivo), str(carpeta_otros / archivo.name))\n                print(f'Movido: {archivo.name} -> Otros')\n\n# Ejecutar\norganizar_descargas('C:/Users/Usuario/Downloads')\n\n2. **BACKUP AUTOMÁTICO**:\nimport zipfile\nimport schedule\nimport time\nfrom datetime import datetime\n\ndef hacer_backup(ruta_origen, ruta_destino):\n    fecha = datetime.now().strftime('%Y%m%d_%H%M%S')\n    nombre_backup = f'backup_{fecha}.zip'\n    ruta_completa = Path(ruta_destino) / nombre_backup\n    \n    with zipfile.ZipFile(ruta_completa, 'w', zipfile.ZIP_DEFLATED) as zipf:\n        for root, dirs, files in os.walk(ruta_origen):\n            for file in files:\n                if not file.endswith('.tmp'):  # Ignorar temporales\n                    ruta_archivo = Path(root) / file\n                    arcname = ruta_archivo.relative_to(ruta_origen)\n                    zipf.write(ruta_archivo, arcname)\n    \n    print(f'Backup creado: {ruta_completa}')\n    \n    # Eliminar backups antiguos (más de 7 días)\n    eliminar_backups_antiguos(ruta_destino, dias=7)\n    \n    return ruta_completa\n\ndef eliminar_backups_antiguos(ruta, dias=7):\n    ahora = datetime.now()\n    limite = ahora - datetime.timedelta(days=dias)\n    \n    for archivo in Path(ruta).glob('backup_*.zip'):\n        fecha_str = archivo.stem.split('_')[1]\n        fecha_backup = datetime.strptime(fecha_str, '%Y%m%d')\n        \n        if fecha_backup < limite:\n            archivo.unlink()\n            print(f'Eliminado backup antiguo: {archivo.name}')\n\n# Programar backup diario a las 2 AM\nschedule.every().day.at('02:00').do(\n    hacer_backup, \n    ruta_origen='C:/Proyectos', \n    ruta_destino='D:/Backups'\n)\n\nprint('Programador de backup iniciado. Presiona Ctrl+C para detener.')\ntry:\n    while True:\n        schedule.run_pending()\n        time.sleep(60)  # Verificar cada minuto\nexcept KeyboardInterrupt:\n    print('\\nBackup detenido.')\n\n3. **AUTOMATIZACIÓN WEB**:\nfrom selenium import webdriver\nfrom selenium.webdriver.common.by import By\nimport time\n\ndef publicar_tweet(usuario, password, mensaje):\n    driver = webdriver.Chrome()\n    try:\n        # Iniciar sesión en Twitter/X\n        driver.get('https://twitter.com/login')\n        time.sleep(2)\n        \n        # Ingresar credenciales\n        usuario_input = driver.find_element(By.NAME, 'text')\n        usuario_input.send_keys(usuario)\n        usuario_input.send_keys(Keys.RETURN)\n        time.sleep(2)\n        \n        password_input = driver.find_element(By.NAME, 'password')\n        password_input.send_keys(password)\n        password_input.send_keys(Keys.RETURN)\n        time.sleep(3)\n        \n        # Publicar tweet\n        tweet_box = driver.find_element(By.CSS_SELECTOR, '[data-testid=\"tweetTextarea_0\"]')\n        tweet_box.send_keys(mensaje)\n        time.sleep(1)\n        \n        tweet_button = driver.find_element(By.CSS_SELECTOR, '[data-testid=\"tweetButtonInline\"]')\n        tweet_button.click()\n        time.sleep(2)\n        \n        print(f'Tweet publicado: {mensaje[:50]}...')\n        \n    finally:\n        driver.quit()\n\n# Usar con cuidado y respetar términos de servicio\n\n4. **AUTOMATIZACIÓN DE EMAIL**:\nimport smtplib\nfrom email.mime.text import MIMEText\nfrom email.mime.multipart import MIMEMultipart\nfrom email.mime.application import MIMEApplication\nimport schedule\n\ndef enviar_reporte_email(destinatarios, asunto, cuerpo, archivo_adjunto=None):\n    # Configuración\n    remitente = 'tu_email@gmail.com'\n    password = 'tu_password_app'  # Usar contraseña de aplicación\n    \n    # Crear mensaje\n    mensaje = MIMEMultipart()\n    mensaje['From'] = remitente\n    mensaje['To'] = ', '.join(destinatarios)\n    mensaje['Subject'] = asunto\n    \n    # Cuerpo del email\n    mensaje.attach(MIMEText(cuerpo, 'plain'))\n    \n    # Adjuntar archivo si existe\n    if archivo_adjunto and Path(archivo_adjunto).exists():\n        with open(archivo_adjunto, 'rb') as archivo:\n            adjunto = MIMEApplication(archivo.read(), _subtype='pdf')\n            adjunto.add_header('Content-Disposition', 'attachment', \n                              filename=Path(archivo_adjunto).name)\n            mensaje.attach(adjunto)\n    \n    # Enviar\n    with smtplib.SMTP('smtp.gmail.com', 587) as servidor:\n        servidor.starttls()\n        servidor.login(remitente, password)\n        servidor.send_message(mensaje)\n    \n    print(f'Email enviado a {len(destinatarios)} destinatarios')\n\ndef generar_reporte_diario():\n    # Generar algún reporte\n    from datetime import datetime\n    fecha = datetime.now().strftime('%d/%m/%Y')\n    cuerpo = f'Reporte diario {fecha}\\n\\n'\n    cuerpo += 'Resumen de actividades:\\n'\n    cuerpo += '- Tarea 1 completada\\n'\n    cuerpo += '- Tarea 2 en progreso\\n'\n    cuerpo += '- Nuevos registros: 150\\n'\n    # Aquí generarías el reporte real\n    \n    enviar_reporte_email(\n        destinatarios=['jefe@empresa.com', 'equipo@empresa.com'],\n        asunto=f'Reporte Diario - {fecha}',\n        cuerpo=cuerpo,\n        archivo_adjunto='reporte_diario.pdf'\n    )\n\n# Programar envío diario a las 18:00\nschedule.every().day.at('18:00').do(generar_reporte_diario)\n\n5. **AUTOMATIZACIÓN DE OFICINA**:\nimport pandas as pd\nfrom openpyxl import load_workbook\nfrom docx import Document\n\ndef procesar_reportes_excel():\n    # Leer múltiples archivos Excel\n    ruta_plantilla = 'plantilla.xlsx'\n    datos = []\n    \n    for archivo in Path('entrada/').glob('*.xlsx'):\n        df = pd.read_excel(archivo)\n        df['Fuente'] = archivo.name\n        datos.append(df)\n    \n    # Consolidar\n    if datos:\n        consolidado = pd.concat(datos, ignore_index=True)\n        \n        # Calcular métricas\n        resumen = pd.DataFrame({\n            'Total Registros': [len(consolidado)],\n            'Promedio Valor': [consolidado['Valor'].mean()],\n            'Máximo Valor': [consolidado['Valor'].max()],\n            'Fecha Proceso': [pd.Timestamp.now()]\n        })\n        \n        # Escribir resultados\n        with pd.ExcelWriter('salida/reporte_consolidado.xlsx', engine='openpyxl') as writer:\n            consolidado.to_excel(writer, sheet_name='Datos', index=False)\n            resumen.to_excel(writer, sheet_name='Resumen', index=False)\n        \n        print(f'Reporte generado: salida/reporte_consolidado.xlsx')\n        return True\n    \n    return False\n\ndef generar_documento_word(datos, plantilla='plantilla.docx'):\n    doc = Document(plantilla)\n    \n    # Reemplazar marcadores\n    for parrafo in doc.paragraphs:\n        if '{{FECHA}}' in parrafo.text:\n            parrafo.text = parrafo.text.replace('{{FECHA}}', datetime.now().strftime('%d/%m/%Y'))\n        if '{{TOTAL}}' in parrafo.text:\n            parrafo.text = parrafo.text.replace('{{TOTAL}}', str(datos['total']))\n    \n    # Agregar tabla\n    tabla = doc.add_table(rows=1, cols=3)\n    tabla.style = 'Light Shading'\n    \n    # Encabezados\n    encabezados = tabla.rows[0].cells\n    encabezados[0].text = 'ID'\n    encabezados[1].text = 'Nombre'\n    encabezados[2].text = 'Valor'\n    \n    # Datos (ejemplo)\n    for i in range(5):\n        fila = tabla.add_row().cells\n        fila[0].text = str(i+1)\n        fila[1].text = f'Item {i+1}'\n        fila[2].text = str(100 * (i+1))\n    \n    doc.save('salida/documento_generado.docx')\n    print('Documento Word generado')\n\n6. **MONITOREO DE SISTEMA**:\nimport psutil\nimport logging\nfrom datetime import datetime\n\ndef monitorear_sistema(umbral_cpu=80, umbral_memoria=80):\n    metrics = {\n        'timestamp': datetime.now().isoformat(),\n        'cpu_percent': psutil.cpu_percent(interval=1),\n        'memory_percent': psutil.virtual_memory().percent,\n        'disk_percent': psutil.disk_usage('/').percent,\n        'network_io': psutil.net_io_counters(),\n        'processes': len(psutil.pids()),\n    }\n    \n    # Alertas\n    alertas = []\n    if metrics['cpu_percent'] > umbral_cpu:\n        alertas.append(f'CPU alto: {metrics[\"cpu_percent\"]}%')\n    \n    if metrics['memory_percent'] > umbral_memoria:\n        alertas.append(f'Memoria alta: {metrics[\"memory_percent\"]}%')\n    \n    # Loggear\n    logging.basicConfig(filename='monitor.log', level=logging.INFO)\n    log_msg = f\"CPU: {metrics['cpu_percent']}%, Mem: {metrics['memory_percent']}%\"\n    \n    if alertas:\n        logging.warning(f'ALERTAS: {\", \".join(alertas)} - {log_msg}')\n        # Podrías enviar email o notificación aquí\n    else:\n        logging.info(log_msg)\n    \n    return metrics, alertas\n\n# Ejecutar monitoreo cada 5 minutos\nschedule.every(5).minutes.do(monitorear_sistema)\n\n7. **TAREAS PROGRAMADAS EN WINDOWS/LINUX**:\n# En Windows: Task Scheduler\n# En Linux: Cron\n\n# Para crear tarea programada en Python:\ndef crear_tarea_cron(comando, hora='0 2 * * *'):\n    \"\"\"\n    hora formato: minuto hora dia mes dia_semana\n    \"\"\"\n    comando_cron = f'{hora} {comando}'\n    \n    # En Linux\n    # with open('/tmp/nueva_tarea', 'w') as f:\n    #     f.write(comando_cron)\n    # os.system('crontab /tmp/nueva_tarea')\n    \n    print(f'Tarea programada: {comando_cron}')\n\n# Consejos:\n# 1. Maneja errores con try-except\n# 2. Loggea todas las acciones\n# 3. No hardcodees credenciales\n# 4. Prueba en entorno seguro primero\n# 5. Considera seguridad y permisos"}
{"prompt": "Cómo trabajar con APIs REST en Python.", "response": "Guía completa para consumir APIs REST:\n\n1. **REQUESTS BÁSICO**:\nimport requests\nimport json\n\n# GET request\ndef obtener_datos(api_url):\n    try:\n        response = requests.get(api_url, timeout=10)\n        response.raise_for_status()  # Lanza excepción para códigos 4xx/5xx\n        return response.json()  # Convertir a dict/list\n    except requests.exceptions.RequestException as e:\n        print(f'Error en la solicitud: {e}')\n        return None\n\n# Ejemplo: API pública\ndatos = obtener_datos('https://jsonplaceholder.typicode.com/posts/1')\nif datos:\n    print(f'Post ID: {datos[\"id\"]}')\n    print(f'Título: {datos[\"title\"]}')\n\n2. **PARÁMETROS DE QUERY**:\ndef buscar_posts(user_id=None, titulo=None):\n    url = 'https://jsonplaceholder.typicode.com/posts'\n    params = {}\n    \n    if user_id:\n        params['userId'] = user_id\n    \n    # Nota: esta API no soporta búsqueda por título, es solo ejemplo\n    if titulo:\n        params['title_like'] = titulo\n    \n    response = requests.get(url, params=params)\n    response.raise_for_status()\n    return response.json()\n\n# Uso\nposts_usuario_1 = buscar_posts(user_id=1)\nprint(f'Posts del usuario 1: {len(posts_usuario_1)}')\n\n3. **POST CON DATOS**:\ndef crear_post(titulo, cuerpo, user_id=1):\n    url = 'https://jsonplaceholder.typicode.com/posts'\n    \n    datos = {\n        'title': titulo,\n        'body': cuerpo,\n        'userId': user_id\n    }\n    \n    headers = {\n        'Content-Type': 'application/json',\n        'Accept': 'application/json'\n    }\n    \n    response = requests.post(url, json=datos, headers=headers)\n    response.raise_for_status()\n    \n    print(f'Status Code: {response.status_code}')\n    print(f'Respuesta: {response.json()}')\n    \n    return response.json()\n\n# Uso\nnuevo_post = crear_post('Mi título', 'Contenido del post')\nprint(f'Nuevo post ID: {nuevo_post.get(\"id\")}')\n\n4. **PUT/PATCH PARA ACTUALIZAR**:\ndef actualizar_post(post_id, datos_actualizados):\n    url = f'https://jsonplaceholder.typicode.com/posts/{post_id}'\n    \n    # PUT reemplaza todo el recurso\n    response = requests.put(url, json=datos_actualizados)\n    \n    # O PATCH para actualización parcial\n    # response = requests.patch(url, json=datos_actualizados)\n    \n    response.raise_for_status()\n    return response.json()\n\n# DELETE\ndef eliminar_post(post_id):\n    url = f'https://jsonplaceholder.typicode.com/posts/{post_id}'\n    response = requests.delete(url)\n    response.raise_for_status()\n    return response.status_code == 200\n\n5. **HEADERS PERSONALIZADOS**:\ndef solicitud_con_headers():\n    url = 'https://api.ejemplo.com/datos'\n    \n    headers = {\n        'Authorization': 'Bearer TU_TOKEN_AQUI',\n        'User-Agent': 'MiAppPython/1.0',\n        'Accept': 'application/json',\n        'Accept-Language': 'es-ES,es;q=0.9',\n    }\n    \n    response = requests.get(url, headers=headers)\n    return response.json()\n\n6. **AUTENTICACIÓN**:\n# Basic Auth\ndef autenticacion_basica():\n    url = 'https://api.ejemplo.com/protegido'\n    response = requests.get(url, auth=('usuario', 'password'))\n    return response.json()\n\n# Bearer Token\ndef autenticacion_token():\n    url = 'https://api.ejemplo.com/protegido'\n    token = 'TU_TOKEN_JWT'\n    headers = {'Authorization': f'Bearer {token}'}\n    response = requests.get(url, headers=headers)\n    return response.json()\n\n# OAuth2\nfrom requests_oauthlib import OAuth2Session\n\ndef autenticacion_oauth2():\n    client_id = 'TU_CLIENT_ID'\n    client_secret = 'TU_CLIENT_SECRET'\n    token_url = 'https://api.ejemplo.com/oauth/token'\n    \n    oauth = OAuth2Session(client_id)\n    token = oauth.fetch_token(\n        token_url=token_url,\n        client_secret=client_secret,\n        username='usuario',\n        password='password'\n    )\n    \n    # Usar token para solicitudes\n    response = oauth.get('https://api.ejemplo.com/datos')\n    return response.json()\n\n7. **MANEJO DE SESIONES**:\nclass APIClient:\n    def __init__(self, base_url, token=None):\n        self.base_url = base_url\n        self.session = requests.Session()\n        \n        if token:\n            self.session.headers.update({\n                'Authorization': f'Bearer {token}'\n            })\n        \n        # Headers por defecto\n        self.session.headers.update({\n            'Accept': 'application/json',\n            'Content-Type': 'application/json',\n            'User-Agent': 'APIClient/1.0'\n        })\n    \n    def get(self, endpoint, params=None):\n        url = f'{self.base_url}/{endpoint.lstrip(\"/\")}'\n        response = self.session.get(url, params=params)\n        response.raise_for_status()\n        return response.json()\n    \n    def post(self, endpoint, data=None):\n        url = f'{self.base_url}/{endpoint.lstrip(\"/\")}'\n        response = self.session.post(url, json=data)\n        response.raise_for_status()\n        return response.json()\n    \n    def close(self):\n        self.session.close()\n\n# Uso\nclient = APIClient('https://jsonplaceholder.typicode.com')\ntry:\n    posts = client.get('/posts')\n    print(f'Total posts: {len(posts)}')\nfinally:\n    client.close()\n\n8. **MANEJO DE ERRORES ROBUSTO**:\ndef solicitud_segura(url, max_reintentos=3):\n    for intento in range(max_reintentos):\n        try:\n            response = requests.get(url, timeout=10)\n            response.raise_for_status()\n            return response.json()\n            \n        except requests.exceptions.Timeout:\n            print(f'Timeout (intento {intento + 1}/{max_reintentos})')\n            if intento == max_reintentos - 1:\n                raise\n                \n        except requests.exceptions.HTTPError as e:\n            if response.status_code == 429:  # Too Many Requests\n                wait_time = int(response.headers.get('Retry-After', 60))\n                print(f'Rate limit. Esperando {wait_time} segundos...')\n                time.sleep(wait_time)\n            elif response.status_code == 401:\n                print('No autorizado. Token puede haber expirado.')\n                # Aquí podrías renovar token\n                raise\n            else:\n                print(f'Error HTTP {response.status_code}: {e}')\n                raise\n                \n        except requests.exceptions.RequestException as e:\n            print(f'Error de conexión: {e}')\n            if intento == max_reintentos - 1:\n                raise\n                \n        time.sleep(2 ** intento)  # Backoff exponencial\n    \n    return None\n\n9. **API PAGINADA**:\ndef obtener_todos_posts(pagina_inicio=1):\n    base_url = 'https://jsonplaceholder.typicode.com/posts'\n    pagina = pagina_inicio\n    todos_posts = []\n    \n    while True:\n        params = {\n            '_page': pagina,\n            '_limit': 10  # Items por página\n        }\n        \n        response = requests.get(base_url, params=params)\n        response.raise_for_status()\n        \n        posts_pagina = response.json()\n        \n        if not posts_pagina:\n            break  # No hay más datos\n        \n        todos_posts.extend(posts_pagina)\n        \n        # Verificar si hay más páginas\n        # Algunas APIs usan headers Link\n        if 'Link' in response.headers:\n            links = parse_header_links(response.headers['Link'])\n            if 'next' not in links:\n                break\n        \n        pagina += 1\n        \n        # Pequeña pausa para no sobrecargar API\n        time.sleep(0.1)\n    \n    return todos_posts\n\ndef parse_header_links(link_header):\n    \"\"\"Parsear header Link de GitHub style\"\"\"\n    links = {}\n    if link_header:\n        for link in link_header.split(','):\n            segmentos = link.split(';')\n            if len(segmentos) < 2:\n                continue\n            url = segmentos[0][segmentos[0].find('<')+1:segmentos[0].find('>')]\n            rel = segmentos[1].strip()[5:-1]  # rel=\"next\" -> next\n            links[rel] = url\n    return links\n\n10. **SUBIR ARCHIVOS**:\ndef subir_archivo(archivo_path, url_api):\n    with open(archivo_path, 'rb') as archivo:\n        files = {'file': (Path(archivo_path).name, archivo, 'application/octet-stream')}\n        \n        response = requests.post(url_api, files=files)\n        response.raise_for_status()\n        \n    return response.json()\n\n# Para múltiples archivos\nfiles = [\n    ('files', ('archivo1.txt', open('archivo1.txt', 'rb'), 'text/plain')),\n    ('files', ('archivo2.jpg', open('archivo2.jpg', 'rb'), 'image/jpeg'))\n]\n\n11. **API RATE LIMITING**:\nfrom ratelimit import limits, sleep_and_retry\n\n# Decorador para limitar a 10 llamadas por minuto\n@sleep_and_retry\n@limits(calls=10, period=60)\ndef llamada_api_limitada():\n    response = requests.get('https://api.ejemplo.com')\n    return response.json()\n\n12. **CACHE DE RESPUESTAS**:\nimport requests_cache\n\n# Instalar: pip install requests-cache\n\n# Configurar cache\nrequests_cache.install_cache(\n    'api_cache',\n    expire_after=300,  # 5 minutos\n    allowable_methods=['GET']\n)\n\n# Las respuestas GET se cachearán automáticamente\n\n13. **WEBHOOKS/RESPUESTAS ASÍNCRONAS**:\nfrom flask import Flask, request, jsonify\n\napp = Flask(__name__)\n\n@app.route('/webhook', methods=['POST'])\ndef webhook():\n    data = request.json\n    \n    # Procesar datos del webhook\n    print(f'Evento recibido: {data.get(\"event\")}')\n    \n    # Siempre responder rápido\n    return jsonify({'status': 'received'}), 200\n\n# Enviar webhook\ndef enviar_webhook(url_webhook, datos):\n    try:\n        response = requests.post(url_webhook, json=datos, timeout=5)\n        response.raise_for_status()\n    except requests.exceptions.Timeout:\n        print('Webhook timeout, pero eso está OK para asíncrono')\n    except Exception as e:\n        print(f'Error enviando webhook: {e}')\n\n14. **OPENAPI/CLIENTES GENERADOS**:\n# Para APIs con OpenAPI spec, puedes generar cliente\n# pip install openapi-client-generator\n\n# O usar herramientas como swagger-codegen\n\n15. **EJEMPLO REAL: GITHUB API**:\nclass GitHubAPI:\n    def __init__(self, token=None):\n        self.base_url = 'https://api.github.com'\n        self.session = requests.Session()\n        \n        if token:\n            self.session.headers.update({\n                'Authorization': f'token {token}',\n                'Accept': 'application/vnd.github.v3+json'\n            })\n    \n    def get_user(self, username):\n        response = self.session.get(f'{self.base_url}/users/{username}')\n        response.raise_for_status()\n        return response.json()\n    \n    def get_user_repos(self, username, sort='updated'):\n        params = {'sort': sort, 'per_page': 100}\n        response = self.session.get(\n            f'{self.base_url}/users/{username}/repos',\n            params=params\n        )\n        response.raise_for_status()\n        return response.json()\n    \n    def create_repo(self, name, private=False, description=''):\n        data = {\n            'name': name,\n            'private': private,\n            'description': description,\n            'auto_init': True\n        }\n        response = self.session.post(\n            f'{self.base_url}/user/repos',\n            json=data\n        )\n        response.raise_for_status()\n        return response.json()\n\n# Uso\ngithub = GitHubAPI()  # Sin token para acceso público\nusuario = github.get_user('torvalds')\nprint(f'Nombre: {usuario[\"name\"]}')\nprint(f'Repos públicos: {usuario[\"public_repos\"]}')\n\n# Consejos:\n# 1. Lee la documentación de la API\n# 2. Implementa rate limiting\n# 3. Cachea cuando sea apropiado\n# 4. Maneja errores gracefulmente\n# 5. Usa variables de entorno para credenciales\n# 6. Considera usar bibliotecas específicas si existen"}
